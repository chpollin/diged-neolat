<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lucina Digital Edition - Madrid BN Mss. 6028</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <!-- Navigation Bar -->
    <header class="nav" role="banner">
        <div class="nav-left">
            <div class="brand">Lucina Digital Edition</div>
        </div>

        <div class="nav-center">
            <div class="view-toggle">
                <button class="toggle active" data-view="latin">Latin</button>
                <button class="toggle" data-view="commentary">Commentary</button>
                <button class="toggle" data-view="translation">Translation</button>
            </div>
        </div>

        <div class="nav-right">
            <label class="sr-only" for="bookSelect">Book</label>
            <select id="bookSelect" class="nav-select">
                <option value="">All Books</option>
            </select>

            <label class="sr-only" for="poemSelect">Poem</label>
            <select id="poemSelect" class="nav-select">
                <option value="">Select Poem</option>
            </select>

            <div class="searchbox">
                <input id="searchInput" class="search-input" type="search" placeholder="Search...">
                <div class="search-meta" id="searchMeta" style="display:none">
                    <span id="searchCount">0</span>
                    <button id="prevResult" class="icon-btn">‚Üê</button>
                    <button id="nextResult" class="icon-btn">‚Üí</button>
                </div>
            </div>

            <button id="infoBtn" class="icon-btn">‚ÑπÔ∏è</button>
            <button id="debugBtn" class="icon-btn" title="Toggle Debug">üêõ</button>
        </div>
    </header>

    <!-- Main Layout -->
    <main id="layout">
        <!-- Text Panel -->
        <section id="textPanel">
            <div id="latinView" class="text-view active" data-view="latin">
                <div class="loading">Loading manuscript...</div>
            </div>
            <div id="commentaryView" class="text-view" data-view="commentary">
                <div class="commentary-view">
                    <p>Commentary view - coming soon</p>
                </div>
            </div>
            <div id="translationView" class="text-view" data-view="translation">
                <div class="translation-view">
                    <p>Translation view - coming soon</p>
                </div>
            </div>
        </section>

        <!-- Image Panel (renamed from imageViewer) -->
        <section id="imagePanel">
            <div class="image-controls">
                <div class="left">
                    <button id="zoomOut" class="icon-btn">‚àí</button>
                    <button id="zoomIn" class="icon-btn">+</button>
                    <button id="zoomFit" class="icon-btn">Fit</button>
                    <button id="rotateBtn" class="icon-btn">‚Üª</button>
                </div>
                <div class="center" id="pageInfo">Page ‚Äî</div>
                <div class="right" style="justify-content: flex-end">
                    <button id="prevPage" class="icon-btn">‚Üê</button>
                    <button id="nextPage" class="icon-btn">‚Üí</button>
                </div>
            </div>
            <div class="image-stage" id="imageContainer">
                <div class="image-overlay" style="display:flex">Select a poem to view manuscript</div>
            </div>
        </section>
    </main>

    <!-- About Dialog -->
    <div id="aboutDialog" hidden>
        <div class="dialog-content">
            <h2>About Lucina Digital Edition</h2>
            <p>Digital edition of Aurelius Laurentius Albrisius's <em>Lucina</em> (1474)</p>
            <p>Madrid, Biblioteca Nacional, Mss. 6028</p>
            <p>128 Latin elegiac poems in three books</p>
            <button id="closeDialog" class="btn" style="margin-top: 1rem;">Close</button>
        </div>
    </div>

    <!-- Debug Panel -->
    <div id="debugPanel" class="debug-panel">
        <div id="debugContent"></div>
    </div>

    <script>
        // Global State with extensive logging
        let teiDoc = null;
        let poems = [];
        let pageMapping = {};
        let persons = {};
        let currentPage = null;
        let currentZoom = 1;
        let currentRotation = 0;
        let searchResults = [];
        let currentSearchIndex = -1;
        let allPages = [];
        let debugMode = false;

        // Debug logging function
        function debugLog(category, message, data = null) {
            const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
            const logMsg = `[${timestamp}] ${category}: ${message}`;
            
            console.log(logMsg, data || '');
            
            if (debugMode) {
                const debugContent = document.getElementById('debugContent');
                if (debugContent) {
                    const entry = document.createElement('div');
                    entry.innerHTML = `<strong>${category}:</strong> ${message}`;
                    if (data) {
                        entry.innerHTML += ` <code>${JSON.stringify(data, null, 2).substring(0, 100)}</code>`;
                    }
                    debugContent.insertBefore(entry, debugContent.firstChild);
                    
                    // Keep only last 20 entries
                    while (debugContent.children.length > 20) {
                        debugContent.removeChild(debugContent.lastChild);
                    }
                }
            }
        }

        // Initialize Application
        document.addEventListener('DOMContentLoaded', () => {
            debugLog('INIT', 'Application starting');
            console.log('Current location:', window.location.href);
            console.log('Base path:', window.location.pathname);
            
            loadTEI();
            setupEventListeners();
            setupViewToggle();
            handleURLState();
        });

        // Load and Parse TEI XML
        async function loadTEI() {
            const teiPath = './tei-final-3-1.xml';
            debugLog('TEI', `Loading TEI from: ${teiPath}`);
            
            try {
                const response = await fetch(teiPath);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const xmlString = await response.text();
                debugLog('TEI', `Loaded XML, size: ${xmlString.length} bytes`);
                
                const parser = new DOMParser();
                teiDoc = parser.parseFromString(xmlString, 'text/xml');
                
                // Check for parsing errors
                const parserError = teiDoc.querySelector('parsererror');
                if (parserError) {
                    throw new Error('XML parsing failed: ' + parserError.textContent);
                }
                
                debugLog('TEI', 'XML parsed successfully');
                
                // Extract data
                extractPageMapping();
                extractPersons();
                extractPoems();
                
                // Verify extraction
                verifyExtraction();
                
                // Populate UI
                populateBookSelector();
                populatePoemSelector();
                renderPoems();
                setupScrollObserver();
                
                // Remove loading state
                document.querySelector('.loading').style.display = 'none';
                
            } catch (error) {
                console.error('Failed to load TEI:', error);
                debugLog('ERROR', `TEI loading failed: ${error.message}`);
                document.querySelector('.loading').textContent = `Failed to load: ${error.message}`;
            }
        }

        // Extract page-to-image mapping from TEI
        function extractPageMapping() {
            debugLog('EXTRACT', 'Starting page mapping extraction');
            
            const pageBreaks = teiDoc.querySelectorAll('pb');
            debugLog('EXTRACT', `Found ${pageBreaks.length} page breaks`);
            
            pageBreaks.forEach((pb, index) => {
                const facs = pb.getAttribute('facs');
                const n = pb.getAttribute('n');
                
                if (facs && n) {
                    // The TEI already has page numbers in format "6.1", "6.2" etc
                    pageMapping[n] = facs;
                    allPages.push(n);
                    
                    if (index < 5 || index >= pageBreaks.length - 5) {
                        debugLog('PAGE', `Mapped page ${n} ‚Üí ${facs}`);
                    }
                }
            });
            
            console.log('Full page mapping:', pageMapping);
            console.log('Total pages mapped:', Object.keys(pageMapping).length);
            console.log('All page numbers:', allPages);
            debugLog('EXTRACT', `Extracted ${Object.keys(pageMapping).length} page mappings`);
        }

        // Extract person data from standOff
        function extractPersons() {
            debugLog('EXTRACT', 'Starting person extraction');
            
            const listPerson = teiDoc.querySelector('standOff listPerson');
            if (listPerson) {
                const personElements = listPerson.querySelectorAll('person');
                debugLog('EXTRACT', `Found ${personElements.length} person elements`);
                
                personElements.forEach(person => {
                    const id = person.getAttribute('xml:id');
                    const persName = person.querySelector('persName');
                    const note = person.querySelector('note');
                    
                    if (id && persName) {
                        persons[id] = {
                            name: persName.textContent.trim(),
                            role: note ? note.textContent.trim() : ''
                        };
                        debugLog('PERSON', `Added: ${id} = ${persons[id].name}`);
                    }
                });
            } else {
                debugLog('EXTRACT', 'No standOff/listPerson found in TEI');
            }
            
            console.log('Extracted persons:', persons);
        }

        // Extract poems from TEI
        function extractPoems() {
            debugLog('EXTRACT', 'Starting poem extraction');
            
            const poemDivs = teiDoc.querySelectorAll('div[type="poem"]');
            debugLog('EXTRACT', `Found ${poemDivs.length} poem divs`);
            
            poemDivs.forEach((poemDiv, index) => {
                const bookDiv = poemDiv.closest('div[type="book"]');
                const bookNum = bookDiv?.getAttribute('n') || '1';
                const poemNum = poemDiv.getAttribute('n') || (index + 1).toString();
                const head = poemDiv.querySelector('head');
                const title = head ? head.textContent.trim() : 'Untitled';
                
                // Extract lines and page breaks
                const lines = [];
                const pageBreaks = [];
                
                // Get all line groups
                const lgElements = poemDiv.querySelectorAll('lg');
                lgElements.forEach(lg => {
                    // Process all child nodes to maintain order
                    lg.childNodes.forEach(node => {
                        if (node.nodeType === 1) { // Element node
                            if (node.tagName === 'l') {
                                const lineNum = node.getAttribute('n');
                                const lineText = node.textContent.trim();
                                lines.push({
                                    n: parseInt(lineNum) || lines.length + 1,
                                    text: lineText
                                });
                            } else if (node.tagName === 'pb') {
                                const n = node.getAttribute('n');
                                if (n) {
                                    pageBreaks.push({
                                        page: n,
                                        afterLine: lines.length
                                    });
                                }
                            }
                        }
                    });
                });
                
                // Find start page
                let startPage = null;
                // Check for pb before or within poem
                const firstPb = poemDiv.querySelector('pb');
                if (firstPb) {
                    startPage = firstPb.getAttribute('n');
                } else {
                    // Look for preceding pb
                    let prevNode = poemDiv.previousElementSibling;
                    while (prevNode) {
                        if (prevNode.tagName === 'pb') {
                            startPage = prevNode.getAttribute('n');
                            break;
                        }
                        prevNode = prevNode.previousElementSibling;
                    }
                }
                
                const poem = {
                    id: `poem-${bookNum}.${poemNum}`,
                    book: parseInt(bookNum),
                    number: parseInt(poemNum),
                    title: title,
                    lines: lines,
                    pageBreaks: pageBreaks,
                    startPage: startPage
                };
                
                poems.push(poem);
                
                if (index < 3) {
                    debugLog('POEM', `Added poem ${poem.id}: "${title.substring(0, 30)}..." with ${lines.length} lines`);
                }
            });
            
            console.log(`Extracted ${poems.length} poems total`);
            console.log('First 3 poems:', poems.slice(0, 3));
        }

        // Verify extraction completeness
        function verifyExtraction() {
            debugLog('VERIFY', 'Starting extraction verification');
            
            // Count statistics
            const stats = {
                totalPoems: poems.length,
                totalLines: poems.reduce((sum, p) => sum + p.lines.length, 0),
                totalPages: Object.keys(pageMapping).length,
                poemsPerBook: {}
            };
            
            // Count poems per book
            poems.forEach(poem => {
                if (!stats.poemsPerBook[poem.book]) {
                    stats.poemsPerBook[poem.book] = 0;
                }
                stats.poemsPerBook[poem.book]++;
            });
            
            // Verify expected counts
            const expected = {
                poems: 127,  // Based on grep count
                minLines: 2000,  // Approximate
                minPages: 100   // Approximate
            };
            
            console.log('=== EXTRACTION VERIFICATION ===');
            console.log('Statistics:', stats);
            console.log('Expected minimums:', expected);
            
            if (stats.totalPoems < expected.poems) {
                console.warn(`WARNING: Only extracted ${stats.totalPoems} poems, expected ${expected.poems}`);
            }
            
            if (stats.totalLines < expected.minLines) {
                console.warn(`WARNING: Only extracted ${stats.totalLines} lines, expected at least ${expected.minLines}`);
            }
            
            debugLog('VERIFY', `Verification complete: ${stats.totalPoems} poems, ${stats.totalLines} lines, ${stats.totalPages} pages`);
            
            return stats;
        }

        // Populate book selector
        function populateBookSelector() {
            const bookSelect = document.getElementById('bookSelect');
            const books = [...new Set(poems.map(p => p.book))].sort();
            
            debugLog('UI', `Populating book selector with ${books.length} books`);
            
            bookSelect.innerHTML = '<option value="">All Books</option>';
            books.forEach(book => {
                const option = document.createElement('option');
                option.value = book;
                option.textContent = `Book ${book}`;
                bookSelect.appendChild(option);
            });
        }

        // Populate poem selector
        function populatePoemSelector() {
            const poemSelect = document.getElementById('poemSelect');
            const bookSelect = document.getElementById('bookSelect');
            const selectedBook = bookSelect.value;
            
            poemSelect.innerHTML = '<option value="">Select Poem</option>';
            
            const filteredPoems = selectedBook ? 
                poems.filter(p => p.book == selectedBook) : poems;
            
            debugLog('UI', `Populating poem selector with ${filteredPoems.length} poems`);
            
            filteredPoems.forEach(poem => {
                const option = document.createElement('option');
                option.value = poem.id;
                option.textContent = `${poem.book}, ${poem.number} ‚Äî ${poem.title.substring(0, 40)}${poem.title.length > 40 ? '...' : ''}`;
                poemSelect.appendChild(option);
            });
        }

        // Render poems in Latin view
        function renderPoems() {
            const latinView = document.getElementById('latinView');
            latinView.innerHTML = '';
            
            const bookSelect = document.getElementById('bookSelect');
            const selectedBook = bookSelect.value;
            
            const filteredPoems = selectedBook ? 
                poems.filter(p => p.book == selectedBook) : poems;
            
            debugLog('RENDER', `Rendering ${filteredPoems.length} poems`);
            
            filteredPoems.forEach(poem => {
                const poemEl = document.createElement('div');
                poemEl.className = 'poem';
                poemEl.id = poem.id;
                poemEl.dataset.poemId = poem.id;
                poemEl.dataset.book = poem.book;
                poemEl.dataset.number = poem.number;
                if (poem.startPage) {
                    poemEl.dataset.startPage = poem.startPage;
                }
                
                // Add title
                const titleHtml = `
                    <h3 class="poem-id">${getRomanNumeral(poem.book)}, ${poem.number}</h3>
                    <h4 class="poem-title">${wrapPersonReferences(poem.title)}</h4>
                `;
                poemEl.innerHTML = titleHtml;
                
                // Add lines with couplet formatting
                let currentCouplet = null;
                let pageBreakIndex = 0;
                
                poem.lines.forEach((line, index) => {
                    // Check for page break before this line
                    while (pageBreakIndex < poem.pageBreaks.length && 
                           poem.pageBreaks[pageBreakIndex].afterLine === index) {
                        if (currentCouplet) {
                            poemEl.appendChild(currentCouplet);
                            currentCouplet = null;
                        }
                        const pageBreak = document.createElement('span');
                        pageBreak.className = 'page-break';
                        pageBreak.dataset.page = poem.pageBreaks[pageBreakIndex].page;
                        pageBreak.textContent = `‚Äî page ${poem.pageBreaks[pageBreakIndex].page} ‚Äî`;
                        poemEl.appendChild(pageBreak);
                        pageBreakIndex++;
                    }
                    
                    // Create line element
                    const lineEl = document.createElement('div');
                    lineEl.className = line.n % 2 === 1 ? 'line hex' : 'line pent';
                    lineEl.innerHTML = `
                        <span class="ln">${line.n}</span>
                        <span class="txt">${wrapPersonReferences(line.text)}</span>
                    `;
                    
                    // Group into couplets
                    if (line.n % 2 === 1) {
                        if (currentCouplet) {
                            poemEl.appendChild(currentCouplet);
                        }
                        currentCouplet = document.createElement('div');
                        currentCouplet.className = 'couplet';
                        currentCouplet.appendChild(lineEl);
                    } else {
                        if (currentCouplet) {
                            currentCouplet.appendChild(lineEl);
                        } else {
                            // Orphaned pentameter
                            currentCouplet = document.createElement('div');
                            currentCouplet.className = 'couplet';
                            currentCouplet.appendChild(lineEl);
                        }
                    }
                });
                
                // Add final couplet
                if (currentCouplet) {
                    poemEl.appendChild(currentCouplet);
                }
                
                // Check for remaining page breaks
                while (pageBreakIndex < poem.pageBreaks.length) {
                    const pageBreak = document.createElement('span');
                    pageBreak.className = 'page-break';
                    pageBreak.dataset.page = poem.pageBreaks[pageBreakIndex].page;
                    pageBreak.textContent = `‚Äî page ${poem.pageBreaks[pageBreakIndex].page} ‚Äî`;
                    poemEl.appendChild(pageBreak);
                    pageBreakIndex++;
                }
                
                latinView.appendChild(poemEl);
            });
        }

        // Wrap person references with tooltips
        function wrapPersonReferences(text) {
            let result = text;
            
            Object.entries(persons).forEach(([id, person]) => {
                const names = [person.name];
                const parts = person.name.split(' ');
                if (parts.length > 1) {
                    names.push(parts[parts.length - 1]);
                }
                
                names.forEach(name => {
                    const regex = new RegExp(`\\b${name}\\b`, 'gi');
                    result = result.replace(regex, (match) => {
                        return `<span class="person" data-id="${id}" title="${person.name}${person.role ? ' - ' + person.role : ''}">${match}</span>`;
                    });
                });
            });
            
            return result;
        }

        // Convert number to Roman numeral
        function getRomanNumeral(num) {
            const numerals = ['', 'I', 'II', 'III', 'IV', 'V'];
            return numerals[num] || num.toString();
        }

        // Setup scroll observer for image synchronization
        function setupScrollObserver() {
            debugLog('OBSERVER', 'Setting up scroll observer');
            
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        if (entry.target.dataset.startPage) {
                            debugLog('SCROLL', `Poem ${entry.target.id} in view, page: ${entry.target.dataset.startPage}`);
                            updateImage(entry.target.dataset.startPage);
                        } else if (entry.target.dataset.page) {
                            debugLog('SCROLL', `Page break ${entry.target.dataset.page} in view`);
                            updateImage(entry.target.dataset.page);
                        }
                    }
                });
            }, { 
                threshold: 0.5,
                rootMargin: '-100px 0px -100px 0px'
            });

            // Observe poems and page breaks
            const poemElements = document.querySelectorAll('.poem[data-start-page]');
            const pageBreakElements = document.querySelectorAll('.page-break[data-page]');
            
            debugLog('OBSERVER', `Observing ${poemElements.length} poems and ${pageBreakElements.length} page breaks`);
            
            poemElements.forEach(el => observer.observe(el));
            pageBreakElements.forEach(el => observer.observe(el));
        }

        // Update manuscript image
        function updateImage(pageNumber) {
            if (currentPage === pageNumber) return;
            
            currentPage = pageNumber;
            const imagePath = pageMapping[pageNumber];
            const imageContainer = document.getElementById('imageContainer');
            const pageInfo = document.getElementById('pageInfo');
            const overlay = imageContainer.querySelector('.image-overlay');
            
            debugLog('IMAGE', `Updating to page ${pageNumber}`);
            pageInfo.textContent = `Page ${pageNumber}`;
            
            if (imagePath) {
                // Build the correct relative path
                const fullPath = `../../facsimiles/${imagePath}`;
                debugLog('IMAGE', `Loading image from: ${fullPath}`);
                console.log('Full image path:', fullPath);
                
                // Hide overlay
                if (overlay) overlay.style.display = 'none';
                
                // Check if image already exists
                let img = document.getElementById('manuscriptImage');
                if (!img) {
                    img = document.createElement('img');
                    img.id = 'manuscriptImage';
                    imageContainer.appendChild(img);
                }
                
                img.src = fullPath;
                img.style.transform = `scale(${currentZoom}) rotate(${currentRotation}deg)`;
                
                img.onload = () => {
                    debugLog('IMAGE', `Successfully loaded: ${imagePath}`);
                };
                
                img.onerror = () => {
                    debugLog('ERROR', `Failed to load image: ${fullPath}`);
                    console.error('Image load failed:', fullPath);
                    if (overlay) {
                        overlay.style.display = 'flex';
                        overlay.textContent = `Image not available: ${imagePath}`;
                    }
                };
                
                // Setup drag to pan
                setupImageDrag(img);
            } else {
                debugLog('IMAGE', `No image mapping for page ${pageNumber}`);
                if (overlay) {
                    overlay.style.display = 'flex';
                    overlay.textContent = `No image available for page ${pageNumber}`;
                }
            }
        }

        // Setup image dragging
        function setupImageDrag(img) {
            let isDragging = false;
            let startX, startY, scrollLeft, scrollTop;
            
            img.addEventListener('mousedown', (e) => {
                isDragging = true;
                img.style.cursor = 'grabbing';
                startX = e.pageX - img.offsetLeft;
                startY = e.pageY - img.offsetTop;
                scrollLeft = img.parentElement.scrollLeft;
                scrollTop = img.parentElement.scrollTop;
            });
            
            img.addEventListener('mouseleave', () => {
                isDragging = false;
                img.style.cursor = 'grab';
            });
            
            img.addEventListener('mouseup', () => {
                isDragging = false;
                img.style.cursor = 'grab';
            });
            
            img.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                e.preventDefault();
                const x = e.pageX - img.offsetLeft;
                const y = e.pageY - img.offsetTop;
                const walkX = (x - startX) * 2;
                const walkY = (y - startY) * 2;
                img.parentElement.scrollLeft = scrollLeft - walkX;
                img.parentElement.scrollTop = scrollTop - walkY;
            });
        }

        // Setup event listeners
        function setupEventListeners() {
            debugLog('INIT', 'Setting up event listeners');
            
            // Debug toggle
            document.getElementById('debugBtn').addEventListener('click', () => {
                debugMode = !debugMode;
                const panel = document.getElementById('debugPanel');
                panel.classList.toggle('show', debugMode);
                debugLog('DEBUG', `Debug mode: ${debugMode ? 'ON' : 'OFF'}`);
            });
            
            // Book selector
            document.getElementById('bookSelect').addEventListener('change', (e) => {
                debugLog('UI', `Book selected: ${e.target.value || 'All'}`);
                populatePoemSelector();
                renderPoems();
                setupScrollObserver();
            });
            
            // Poem selector
            document.getElementById('poemSelect').addEventListener('change', (e) => {
                if (e.target.value) {
                    debugLog('UI', `Poem selected: ${e.target.value}`);
                    const poem = document.getElementById(e.target.value);
                    if (poem) {
                        poem.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                }
            });
            
            // Zoom controls
            document.getElementById('zoomIn').addEventListener('click', () => {
                currentZoom = Math.min(3, currentZoom + 0.25);
                debugLog('ZOOM', `Zoom in: ${currentZoom}`);
                updateZoom();
            });
            
            document.getElementById('zoomOut').addEventListener('click', () => {
                currentZoom = Math.max(0.5, currentZoom - 0.25);
                debugLog('ZOOM', `Zoom out: ${currentZoom}`);
                updateZoom();
            });
            
            document.getElementById('zoomFit').addEventListener('click', () => {
                currentZoom = 1;
                debugLog('ZOOM', 'Zoom reset to 1');
                updateZoom();
            });
            
            document.getElementById('rotateBtn').addEventListener('click', () => {
                currentRotation = (currentRotation + 90) % 360;
                debugLog('ROTATE', `Rotation: ${currentRotation}¬∞`);
                updateZoom();
            });
            
            // Page navigation
            document.getElementById('prevPage').addEventListener('click', () => {
                const index = allPages.indexOf(currentPage);
                if (index > 0) {
                    debugLog('NAV', `Previous page: ${allPages[index - 1]}`);
                    updateImage(allPages[index - 1]);
                }
            });
            
            document.getElementById('nextPage').addEventListener('click', () => {
                const index = allPages.indexOf(currentPage);
                if (index < allPages.length - 1) {
                    debugLog('NAV', `Next page: ${allPages[index + 1]}`);
                    updateImage(allPages[index + 1]);
                }
            });
            
            // Search
            document.getElementById('searchInput').addEventListener('input', (e) => {
                performSearch(e.target.value);
            });
            
            document.getElementById('prevResult').addEventListener('click', () => {
                navigateSearch(-1);
            });
            
            document.getElementById('nextResult').addEventListener('click', () => {
                navigateSearch(1);
            });
            
            // Info dialog
            document.getElementById('infoBtn').addEventListener('click', () => {
                document.getElementById('aboutDialog').removeAttribute('hidden');
            });
            
            document.getElementById('closeDialog').addEventListener('click', () => {
                document.getElementById('aboutDialog').setAttribute('hidden', '');
            });
            
            document.getElementById('aboutDialog').addEventListener('click', (e) => {
                if (e.target === e.currentTarget) {
                    document.getElementById('aboutDialog').setAttribute('hidden', '');
                }
            });
        }

        // Update zoom
        function updateZoom() {
            const img = document.getElementById('manuscriptImage');
            if (img) {
                img.style.transform = `scale(${currentZoom}) rotate(${currentRotation}deg)`;
            }
        }

        // Setup view toggle
        function setupViewToggle() {
            const toggles = document.querySelectorAll('.toggle');
            const views = document.querySelectorAll('.text-view');
            
            toggles.forEach(toggle => {
                toggle.addEventListener('click', () => {
                    const view = toggle.dataset.view;
                    debugLog('VIEW', `Switching to ${view} view`);
                    
                    // Update toggles
                    toggles.forEach(t => t.classList.remove('active'));
                    toggle.classList.add('active');
                    
                    // Update views
                    views.forEach(v => v.classList.remove('active'));
                    const targetView = document.querySelector(`.text-view[data-view="${view}"]`);
                    if (targetView) {
                        targetView.classList.add('active');
                    }
                });
            });
        }

        // Search functionality
        function performSearch(query) {
            // Clear previous highlights
            document.querySelectorAll('.hl').forEach(el => {
                el.outerHTML = el.textContent;
            });
            
            searchResults = [];
            currentSearchIndex = -1;
            
            if (!query || query.length < 2) {
                document.getElementById('searchMeta').style.display = 'none';
                return;
            }
            
            debugLog('SEARCH', `Searching for: "${query}"`);
            
            // Search in poem text
            const textElements = document.querySelectorAll('.txt');
            const regex = new RegExp(`(${query})`, 'gi');
            
            textElements.forEach(el => {
                if (regex.test(el.textContent)) {
                    el.innerHTML = el.textContent.replace(regex, '<mark class="hl">$1</mark>');
                    el.querySelectorAll('.hl').forEach(highlight => {
                        searchResults.push(highlight);
                    });
                }
            });
            
            // Update search meta
            const searchMeta = document.getElementById('searchMeta');
            const searchCount = document.getElementById('searchCount');
            
            if (searchResults.length > 0) {
                searchMeta.style.display = 'flex';
                searchCount.textContent = searchResults.length;
                currentSearchIndex = 0;
                searchResults[0].classList.add('pulse');
                searchResults[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
                debugLog('SEARCH', `Found ${searchResults.length} results`);
            } else {
                searchMeta.style.display = 'none';
                debugLog('SEARCH', 'No results found');
            }
        }

        // Navigate search results
        function navigateSearch(direction) {
            if (searchResults.length === 0) return;
            
            // Remove current highlight
            if (currentSearchIndex >= 0) {
                searchResults[currentSearchIndex].classList.remove('pulse');
            }
            
            // Update index
            currentSearchIndex += direction;
            if (currentSearchIndex < 0) {
                currentSearchIndex = searchResults.length - 1;
            } else if (currentSearchIndex >= searchResults.length) {
                currentSearchIndex = 0;
            }
            
            // Add current highlight and scroll
            searchResults[currentSearchIndex].classList.add('pulse');
            searchResults[currentSearchIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
            debugLog('SEARCH', `Navigated to result ${currentSearchIndex + 1}/${searchResults.length}`);
        }

        // Handle URL state
        function handleURLState() {
            // Check for hash in URL
            const hash = window.location.hash;
            if (hash) {
                const poemId = hash.substring(1);
                debugLog('URL', `Hash detected: ${poemId}`);
                const poem = document.getElementById(poemId);
                if (poem) {
                    setTimeout(() => {
                        poem.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }, 500);
                }
            }
            
            // Update URL when scrolling
            let scrollTimeout;
            document.getElementById('textPanel').addEventListener('scroll', () => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    const poems = document.querySelectorAll('.poem');
                    const scrollTop = document.getElementById('textPanel').scrollTop;
                    
                    for (let poem of poems) {
                        const rect = poem.getBoundingClientRect();
                        if (rect.top >= 0 && rect.top <= 200) {
                            window.history.replaceState(null, '', '#' + poem.id);
                            break;
                        }
                    }
                }, 100);
            });
        }
    </script>
</body>
</html>